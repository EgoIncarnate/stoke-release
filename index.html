<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="STOKE : A Stochastic Optimizer for x86_64">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>STOKE</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/eschkufz/stoke-release">View on GitHub</a>

          <h1 id="project_title">STOKE</h1>
          <h2 id="project_tagline">A Stochastic Optimizer for x86_64</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/eschkufz/stoke-release/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/eschkufz/stoke-release/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="stoke" class="anchor" href="#stoke" aria-hidden="true"><span class="octicon octicon-link"></span></a>STOKE</h1>

<p>STOKE is a stochastic optimizer for the x86_64 instruciton set. STOKE uses random search to explore the extremely high-dimensional space of all possible program transformations. Although any one random transformation is unlikely to produce a code sequence that is both correct and an improvement over the original, the repeated application of millions of transformations is sufficient to produce novel and non-obvious code sequences that have been shown to outperform the code produced by general-purpose and domain-specific compilers, and in some cases expert hand-written code.</p>

<p>STOKE has appeared in a number of publications. For a thorough introduction to the design of STOKE, please see the following:</p>

<ul>
<li>
<strong>Stochastic Superoptimization</strong> -- ASPLOS 2013 (<a href="http://cs.stanford.edu/people/eschkufz/research/asplos291-schkufza.pdf">link</a>):</li>
<li>
<strong>Data-Driven Equivalence Checking</strong> -- OOPSLA 2013 (<a href="http://cs.stanford.edu/people/eschkufz/research/oopsla011-sharma.pdf">link</a>):</li>
<li>
<strong>Stochastic Optimization of Floating-Point Programs with Tunable Precision</strong> -- PLDI 2014 (<a href="http://cs.stanford.edu/people/eschkufz/research/pldi52-schkufza.pdf">link</a>):</li>
</ul>

<h1>
<a id="table-of-contents" class="anchor" href="#table-of-contents" aria-hidden="true"><span class="octicon octicon-link"></span></a>Table of Contents</h1>

<ol>
<li><a href="https://github.com/eschkufz/stoke#downloading-and-building-stoke">Downloading and Building STOKE</a></li>
<li><a href="https://github.com/eschkufz/stoke#using-stoke">Using STOKE</a></li>
<li><a href="https://github.com/eschkufz/stoke#additional-features">Additional Features</a></li>
<li>
<a href="https://github.com/eschkufz/stoke#extending-stoke">Extending STOKE</a>

<ol>
<li><a href="https://github.com/eschkufz/stoke#code-organization">Code Organization</a></li>
<li><a href="https://github.com/eschkufz/stoke#initial-search-state">Initial Search State</a></li>
<li><a href="https://github.com/eschkufz/stoke#search-transformations">Search Transformations</a></li>
<li><a href="https://github.com/eschkufz/stoke#performance-term">Performance Term</a></li>
<li><a href="https://github.com/eschkufz/stoke#correctness-term">Correctness Term</a></li>
<li><a href="https://github.com/eschkufz/stoke#computing-error">Live-out Error</a></li>
<li><a href="https://github.com/eschkufz/stoke#verification-strategy">Verification Strategy</a></li>
<li><a href="https://github.com/eschkufz/stoke#command-line-args">Command Line Args</a></li>
</ol>
</li>
<li><a href="https://github.com/eschkufz/stoke#frequently-asked-questions">Frequently Asked Questions</a></li>
<li><a href="https://github.com/eschkufz/stoke#contact">Contact</a></li>
</ol>

<h1>
<a id="downloading-and-building-stoke" class="anchor" href="#downloading-and-building-stoke" aria-hidden="true"><span class="octicon octicon-link"></span></a>Downloading and Building STOKE</h1>

<p>The entire STOKE code base, as well as its dependencies are available on github under the Apache Software License version 2.0. To clone a copy of the source code, type:</p>

<pre><code>$ git clone https://github.com/eschkufz/stoke
</code></pre>

<p>The implementation of STOKE is for better or worse highly platform dependent. The current version of STOKE was built and tested in Ubuntu 13.10 on an Intel CPU with full support for the Haswell instruction set. To determine whether your machine satisfies this hardware dependency, type:</p>

<pre><code>$ less /proc/cpuinfo
</code></pre>

<p>and check that the following cpu flags are present:</p>

<pre><code>$ flags: ... avx avx2 bmi bmi2 popcnt ...
</code></pre>

<p>Most of STOKE's software dependencies are available through apt. These can be satisfied by typing:</p>

<pre><code>$ sudo apt-get install flex bison ccache doxygen g++ g++-multilib ghc libghc-regex-tdfa-dev libghc-regex-compat-dev libghc-split-dev
</code></pre>

<p>The remainder of STOKE's software dependencies are available on github and will be downloaded automatically the first time that STOKE is built. To build stoke, type:</p>

<pre><code>$ make
</code></pre>

<p>The files generated during the build process can be deleted by typing:</p>

<pre><code>$ make clean
</code></pre>

<p>To delete STOKE's github-hosted software dependencies as well (this is useful if an error occurs during the first build), type:</p>

<pre><code>$ make dist-clean
</code></pre>

<p>To add STOKE and its related components to your path, type:</p>

<pre><code>$ export PATH=$PATH:/&lt;path_to_stoke&gt;/bin
</code></pre>

<h1>
<a id="using-stoke" class="anchor" href="#using-stoke" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using STOKE</h1>

<p>The following toy example shows a typical workflow for using STOKE. All of the following code can be found in the <code>examples/tutorial/</code> directory. Consider a C++ program that repeatedly counts the number of bits (population count) in the 64-bit representation of an integer. (Keeping track of a running sum prevents <code>g++</code> from eliminating the calls to <code>popcnt()</code> altogether.)</p>

<div class="highlight highlight-c++"><pre><span class="pl-c">// popcnt.cc</span>

#<span class="pl-k">include</span> <span class="pl-s1"><span class="pl-pds">&lt;</span>stddef.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s1"><span class="pl-pds">&lt;</span>stdint.h<span class="pl-pds">&gt;</span></span>

<span class="pl-s3">size_t</span> <span class="pl-en">popcnt</span>(<span class="pl-s3">uint64_t</span> x) {
  <span class="pl-st">int</span> res = <span class="pl-c1">0</span>;
  <span class="pl-k">for</span> ( ; x &gt; <span class="pl-c1">0</span>; x &gt;&gt;= <span class="pl-c1">1</span> ) {
    res += x &amp; 0x1ull;
  }
  <span class="pl-k">return</span> res;
}</pre></div>

<div class="highlight highlight-c++"><pre><span class="pl-c">// main.cc</span>

#<span class="pl-k">include</span> <span class="pl-s1"><span class="pl-pds">&lt;</span>cstdlib<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s1"><span class="pl-pds">&lt;</span>stddef.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s1"><span class="pl-pds">&lt;</span>stdint.h<span class="pl-pds">&gt;</span></span>

<span class="pl-k">using</span> <span class="pl-st">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>

<span class="pl-s">extern</span> <span class="pl-s3">size_t</span> <span class="pl-en">popcnt</span>(<span class="pl-s3">uint64_t</span> x);

<span class="pl-st">int</span> <span class="pl-en">main</span>(<span class="pl-st">int</span> argc, <span class="pl-st">char</span>** argv) {
  <span class="pl-s">const</span> <span class="pl-st">auto</span> itr = <span class="pl-s3">atoi</span>(argv[<span class="pl-c1">1</span>]);

  <span class="pl-st">auto</span> ret = <span class="pl-c1">0</span>;
  <span class="pl-k">for</span> ( <span class="pl-st">auto</span> i = <span class="pl-c1">0</span>; i &lt; itr; ++i ) {
    ret += <span class="pl-s3">popcnt</span>(i);
  }

  <span class="pl-k">return</span> ret;</pre></div>

<p>STOKE is a compiler and programming language agnostic optimization tool. It can be applied to any x86_64 ELF binary. Although this example uses the GNU toolchain, nothing prevents the use of other tools. To build this code with full optimizations, type:</p>

<pre><code>$ g++ -std=c++11 -O3 -c popcnt.cc
$ g++ -std=c++11 -O3 main.cc popcnt.o
</code></pre>

<p>To measure runtime, type:</p>

<pre><code>$ time ./a.out 100000000

real  0m1.046s
user  0m1.047s
sys   0m0.000s
</code></pre>

<p>A profiler will reveal that the runtime of <code>./a.out</code> is dominated by calls to the <code>popcnt()</code> function. STOKE can be used to improve the implementation of this function as follows. The first step is to disassemble the program by typing:</p>

<pre><code>$ stoke extract -i ./a.out -o bins
</code></pre>

<p>This will produce a directory named <code>bins</code> that contains the text of every function contained in the binary <code>./a.out</code>. </p>

<p>Help for stoke or any of its subcommands can be obtained by typing:</p>

<pre><code>$ stoke -h
$ stoke &lt;subcommand&gt; -h
</code></pre>

<p>STOKE can accept arguments either through the command line or through a configuration file. The invocation of <code>stoke extract</code> shown above is equivalent to the following:</p>

<pre><code>$ stoke extract --config extract.conf
</code></pre>

<p>Where <code>extract.conf</code> contains:</p>

<pre><code>##### stoke extract config file

-i ./a.out # Path to the elf binary to disassemble
-o bins # Path to the directory to store disassembled text in
</code></pre>

<p>Every STOKE subcommand can be used to generate example configuration files by typing:</p>

<pre><code>$ stoke &lt;subcommand&gt; --example_config &lt;path/to/file.conf&gt;
</code></pre>

<p>Because <code>main.cc</code> was compiled using <code>g++</code>, the text of the <code>popcnt()</code> function will appear under the mangled name <code>_Z6popcntm</code> in <code>bins/_Z6popcntm.s</code>.</p>

<div class="highlight highlight-asm"><pre>  <span class="pl-s1">.text</span>
  .globl _Z6popcntm
  .type _Z6popcntm, @function
<span class="pl-en">_Z6popcntm:</span>
  <span class="pl-k">xorl</span>   %<span class="pl-s">eax</span>,%<span class="pl-s">eax</span>
  testq  %rdi,%rdi
  <span class="pl-k">je</span>     .L_4005b0
  <span class="pl-k">nop</span>
<span class="pl-en">.L_4005a0:</span>
  movq   %rdi,%rdx
  <span class="pl-k">andl</span>   $<span class="pl-c1">0x1</span>,%<span class="pl-s">edx</span>
  addq   %rdx,%rax
  shrq   $<span class="pl-c1">0x1</span>,%rdi
  <span class="pl-k">jne</span>    .L_4005a0
  retq
<span class="pl-en">.L_4005b0:</span>
  retq
  <span class="pl-k">nop</span>
  <span class="pl-k">nop</span>
  .size _Z6popcntm, .-_Z6popcntm</pre></div>

<p>The next step is to generate a set of testcases for guiding STOKE's search procedure. These can be obtained by typing:</p>

<pre><code>$ stoke testcase --config testcase.conf
</code></pre>

<p>where <code>testcase.conf</code> contains:</p>

<pre><code>##### stoke testcase config file

--bin ./a.out # The name of the binary to use to generate testcases 
--args 10000000 # Command line arguments that should be passed to ./a.out

-o popcnt.tc # Path to file to write testcases to

--fxn _Z6popcntm # The name of the function to generate testcases for
--max_testcases 1024 # The maximum number of testcases to generate. 
</code></pre>

<p>The resulting file will contain 1024 entires, all of the form:</p>

<pre><code>Testcase 0:

%rax     00 00 00 00 00 98 96 80
%rcx     00 00 00 00 00 00 00 00
%rdx     00 00 00 00 00 00 00 0a
%rbx     00 00 00 00 00 00 00 01
%rsp     00 00 7f ff 97 44 36 28
%rbp     00 00 00 00 00 00 00 00
%rsi     19 99 99 99 99 99 99 99
%rdi     00 00 00 00 00 00 00 00
%r8      00 00 2a c9 68 1a 50 40
%r9      00 00 7f ff 97 44 46 01
%r10     00 00 00 00 00 98 96 80
%r11     00 00 00 00 00 00 00 0a
%r12     00 00 00 00 00 98 96 80
%r13     00 00 7f ff 97 44 37 20
%r14     00 00 00 00 00 00 00 00
%r15     00 00 00 00 00 00 00 00

%ymm0    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
%ymm1    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f
%ymm2    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
%ymm3    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff 00 00 00 00 00 00 00 ff
%ymm4    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
%ymm5    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
%ymm6    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
%ymm7    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
%ymm8    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
%ymm9    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
%ymm10   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
%ymm11   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
%ymm12   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
%ymm13   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
%ymm14   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
%ymm15   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

[ 00007fff 97443630 - 00007fff 97443620 ]
[ 1 valid rows shown ]

00007fff 97443628   d d d d d d d d   00 00 00 00 00 40 04 6c

[ 00000000 00000000 - 00000000 00000000 ]
[ 0 valid rows shown ]
</code></pre>

<p>Each entry corresponds to the hardware state that was observed just prior to an execution of the <code>popcnt()</code> function. The first 32 rows represent the contents of general purpose and sse registers, and the remaining rows represent the contents of memory, both on the stack and the heap. Memory is shown eight bytes at a time, where a block of eight bytes appears only if the target dereferenced at least one of those bytes. Each row contains values and state flags. Bytes are flagged as either (v)alid (the target dereferenced this byte), (d)efined (the target read this byte prior to reading its value), or (.)invalid (the target did not dereference this byte). </p>

<p>Each of the random transformations performed by STOKE are evaluated with respect to the contents of this file. Rewrites are compiled into a sandbox and executed beginning from the machine state represented by each entry. Rewrites are only permitted to dereference defined locations. This includes registers that are flagged as <code>def_in</code> (see <code>search.conf</code>, below), memory locations that are flagged as 'd', or locations that were written previously. Rewrites are permitted to write values to all registers and to any memory location that is flagged as valid. </p>

<p>The STOKE sandbox will safely halt the execution of rewrites that perform undefined behavior. This includes leaving registers in a state that violates the x86_64 callee-save ABI, dereferencing invalid memory, performing a computation that results in a floating-point exception, or becoming trapped in a loop that performs more than <code>max_jumps</code> (see <code>search.conf</code>, below). </p>

<p>The final step is to use these testcases and the target code contained in <code>bins/_Z6popcntm.s</code> to run STOKE search by typing:</p>

<pre><code>$ stoke search --config search.conf
</code></pre>

<p>where <code>search.conf</code> contains:</p>

<pre><code>##### stoke search config file

--out result.s # Path to write results to

--target bins/_Z6popcntm.s # Path to the function to optimize
--init empty # Begin search from all nops 

--def_in "{ %rax %rdi }" # The registers that are defined on entry to the target
--live_out "{ %rax }" # The registers that are live on exit from the target

--testcases popcnt.tc # Path to testcase file
--training_set "{ 0 ... 7 }" # Testcases to use for measuring correctness during search
--test_set "{ 8 ... 1023 }"  # Testcases to use as holdout set for checking correctness

--distance hamming # Metric for measuring error between live-outs
--relax_reg # Allow partial credit for results that appear in wrong locations
--misalign_penalty 1 # Penalty for results that appear in the wrong location
--reduction sum # Method for summing errors across testcases
--sig_penalty 9999 # Score to assign to rewrites that produce non-zero signals

--perf size # Measure performance by summing instruction latencies

--cpu_flags "{ popcnt }" # cpuid flags to use when proposing instructions
--mem_read # Propose instructions that read memory
--mem_write # Propose instructions that write memory

--global_swap_mass 1 # Proposal mass
--instruction_mass 1 # Proposal mass
--local_swap_mass 1 # Proposal mass
--opcode_mass 1 # Proposal mass
--operand_mass 1 # Proposal mass
--resize_mass 1 # Proposal mass

--nop_percent 80 # Percent of instruction moves that produce nop
--beta 1 # Search annealing constant
--max_instrs 8 # The maximum number of instruction allowed in a rewrite

--statistics_interval 100000 # Print statistics every 100k proposals
--timeout 1000000 # Propose 1m modifications before giving up
--timeout_action testcase # Try adding a new testcase from the testset when search times out
--timeout_cycles 16 # Timeout up to 16 times before giving up

--strategy hold_out # Verify results using a larger hold out testcase set
</code></pre>

<p>STOKE search will produce two types of status messages. Progress update messages will be printed whenever STOKE discovers a new lowest cost verified or unverified rewrite. The code shown on the left is not equivalent to the target code; the code shown on the right is with respect to the current set of testcases.</p>

<pre><code>Progress Update: 

Lowest Cost Discovered (9)         Lowest Known Correct Cost (15)     

btrq $0xffffffffffffffc0, %rdi     testq %rdi, %rdi      
retq                               je .L_X64ASM_0        
                                   xorl %eax, %eax       
                                   .L_X64ASM_1:          
                                   movl %edi, %edx       
                                   andl $0x1, %edx       
                                   addl %edx, %eax       
                                   shrq $0x1, %rdi       
                                   jne .L_X64ASM_1       
                                   cltq                  
                                   retq                  
                                   .L_X64ASM_0:          
                                   xorl %eax, %eax       
                                   retq
</code></pre>

<p>Statistics updates will be printed every <code>statistics_interval</code> proposals. Statistics are shown for the number of proposals that have taken place, elapsed time, proposal throughput, and for each of the transformations specified to have non-zero mass in <code>search.conf</code>.</p>

<pre><code>Statistics Update: 

Iterations:   100000
Elapsed Time: 0.0836948s
Iterations/s: 1.19482e+06

Move Type       Proposed     Succeeded     Accepted     

Instruction     16.791%      5.83%         2.009%       
Opcode          16.646%      8.857%        4.013%       
Operand         16.593%      10.444%       6.864%       
Resize          16.611%      0.791%        0.789%       
Local Swap      16.597%      1.556%        1.128%       
Global Swap     16.762%      7.066%        6.08%     
Extension       0%           0%            0%

Total           100%         34.544%       20.883%
</code></pre>

<p>When search has run to completion, STOKE will write the lowest cost verified rewrite that it discovered to <code>result.s</code>. Because this is a particularly simple example, STOKE is almost guaranteed to produce the optimal rewrite:</p>

<div class="highlight highlight-asm"><pre>  <span class="pl-s1">.text</span>
  .globl _Z6popcntm
  .type _Z6popcntm @function
<span class="pl-en">_Z6popcntm:</span>
  popcnt %rdi, %rax
  retq
  .size _Z6popcntm, .-_Z6popcntm</pre></div>

<p>The original program can be recompiled using this improved implemenation by typing:</p>

<pre><code>$ g++ -std=c++11 -c result.s 
$ g++ -std=c++11 -O3 main.cc result.o
</code></pre>

<p>And runtime can once again be measured by typing:</p>

<pre><code>$ time ./a.out 100000000

real  0m0.133s
user  0m0.109s
sys   0m0.000s    
</code></pre>

<p>As expected, the results are close to an order of magnitude faster than the original.</p>

<h1>
<a id="additional-features" class="anchor" href="#additional-features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Additional Features</h1>

<p>In addition to the subcommands described above, STOKE has facilities for debugging and benchmarking the performance of each of its core components:</p>

<ul>
<li>
<code>stoke debug cfg</code>: Generate a pdf of a control flow graph.</li>
<li>
<code>stoke debug cost</code>: Compute the cost of a rewrite.</li>
<li>
<code>stoke debug sandbox</code>: Step through the execution of a rewrite.</li>
<li>
<code>stoke debug search</code>: View the changes produced by performing and undoing a program transformation.</li>
<li>
<code>stoke debug state</code>: Check the behavior of operators that manipulate hardware machine states.</li>
<li>
<code>stoke debug verify</code>: Check the equivalence of two programs.</li>
<li>
<code>stoke benchmark cfg</code>: Measure the time required to recompute a control flow graph.</li>
<li>
<code>stoke benchmark cost</code>: Measure the time required to compute a cost function.</li>
<li>
<code>stoke benchmark sandbox</code>: Measure the time required to execute a program in a STOKE sandbox.</li>
<li>
<code>stoke benchmark search</code>: Measure the time required to perform and undo a transformation to a program.</li>
<li>
<code>stoke benchmark state</code>: Measure the time required to reset the memory of a hardware machine state.</li>
<li>
<code>stoke benchmark verify</code>: Measure the time required to check the equivalence of two programs.</li>
</ul>

<h1>
<a id="extending-stoke" class="anchor" href="#extending-stoke" aria-hidden="true"><span class="octicon octicon-link"></span></a>Extending STOKE</h1>

<p>This repository contains a minimal implementation of STOKE as described in ASPLOS 2013, OOPSLA 2013, and PLDI 2014. Most, but not all of the features described in those papers appear here. Some of the more experimental features (notably, a formal verifier) are not yet ready for public release and have not been provided. Developers who are interested in refining these features or adding their own extensions are encouraged to try modifying this implementation as described below.</p>

<h2>
<a id="code-organization" class="anchor" href="#code-organization" aria-hidden="true"><span class="octicon octicon-link"></span></a>Code Organization</h2>

<p>The STOKE source is organized into modules, each of which correspond to a subdirectory of the <code>src/</code> directory:</p>

<ul>
<li>
<code>src/args</code>: Function objects for performing I/O operations on command line arguments.</li>
<li>
<code>src/cfg</code>: Classes for representing and manipulating control flow graphs.</li>
<li>
<code>src/cost</code>: Classes for computing cost functions.</li>
<li>
<code>src/ext</code>: External dependencies.</li>
<li>
<code>src/sandbox</code>: Classes for safely executing random code sequences.</li>
<li>
<code>src/search</code>: Classes for performing MCMC sampling.</li>
<li>
<code>src/state</code>: Classes for representing and manipulating hardware machine states.</li>
<li>
<code>src/tunit</code>: Classes for representing translation units (named instruction sequences).</li>
<li>
<code>src/verifier</code>: Classes for verifying program equivalence.</li>
</ul>

<h2>
<a id="initial-search-state" class="anchor" href="#initial-search-state" aria-hidden="true"><span class="octicon octicon-link"></span></a>Initial Search State</h2>

<p>Initial state types are defined in <code>src/search/init.h</code> along with an additional type for user-defined extensions.</p>

<div class="highlight highlight-c++"><pre><span class="pl-st">enum</span> <span class="pl-st">class</span> <span class="pl-en">Init</span> {
  EMPTY,
  SOURCE,

  <span class="pl-c">// Add user-defined extensions here ...</span>
  EXTENSION
};</pre></div>

<p>Initial state is specified using the <code>--init</code> command line argument. This value controls the behavior of the <code>Search::initialize() const</code> method, which dispatches to the family of <code>Search::xxxxx_init() const</code> methods. User-defined extensions should be placed in the <code>Search::extension_init() const</code> method, which can be triggered by specifying <code>--init extension</code>.</p>

<div class="highlight highlight-c++"><pre>Cfg <span class="pl-en">Search::extension_init</span>(<span class="pl-s">const</span> Cfg&amp; rewrite) <span class="pl-s">const</span> {
  <span class="pl-st">auto</span> ret = rewrite;

  <span class="pl-c">// Add user-defined transformations here ...</span>

  <span class="pl-c">// Invariant 1: ret and rewrite must agree on boundary conditions.</span>
  <span class="pl-s3">assert</span>(ret.<span class="pl-s3">def_in</span>() == rewrite.<span class="pl-s3">def_in</span>());
  <span class="pl-s3">assert</span>(ret.<span class="pl-s3">live_out</span>() == rewrite.<span class="pl-s3">live_out</span>();

  <span class="pl-c">// Invariant 2: ret must be in a valid state. This function isn't on</span>
  <span class="pl-c">// a critical path, so this can safely be accomplished by calling</span>
  ret.<span class="pl-s3">recompute</span>();

  <span class="pl-k">return</span> ret;
} </pre></div>

<h2>
<a id="search-transformations" class="anchor" href="#search-transformations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Search Transformations</h2>

<p>Transformation types are defined in <code>src/search/move.h</code> along with an additional type for user-defined extensions.</p>

<div class="highlight highlight-c++"><pre><span class="pl-st">enum</span> <span class="pl-st">class</span> <span class="pl-en">Move</span> {
  INSTRUCTION = <span class="pl-c1">0</span>,
  OPCODE,
  OPERAND,
  RESIZE,
  LOCAL_SWAP,
  GLOBAL_SWAP,

  <span class="pl-c">// Add user-defined extensions here ...</span>
  EXTENSION,

  NUM_MOVES
};</pre></div>

<p>Transformations are specified using the family of <code>--xxxxx_mass</code> command line arguments. These values control the distribution of proposals that are made by the <code>Transforms::modify()</code> method and undone by the <code>Transforms::undo()</code> method, which dispatch to the family of <code>Transforms::xxxxx_move()</code> and <code>Transforms::undo_xxxxx_move()</code> methods respectively. User-defined extensions should be placed in the <code>Transforms::extension_move()</code> and <code>Transforms::undo_extension_move()</code> methods, which can be triggered by specifying a non-zero <code>--extension_mass</code>.</p>

<div class="highlight highlight-c++"><pre><span class="pl-st">bool</span> <span class="pl-en">Transforms::extension_move</span>(Cfg&amp; cfg) {
  <span class="pl-c">// Add user-defined implementation here ...</span>

  <span class="pl-c">// Invariant 1a:</span>
  <span class="pl-c">// If this method returns true, it should leave this class in a state such that calling</span>
  <span class="pl-c">// undo_extension_move() will revert cfg to its original state.</span>

  <span class="pl-c">// Invariant 1b:</span>
  <span class="pl-c">// If this method returns false, it must leave cfg in its original state.</span>

  <span class="pl-k">return</span> <span class="pl-c1">false</span>;
}</pre></div>

<div class="highlight highlight-c++"><pre><span class="pl-st">void</span> <span class="pl-en">Transforms::undo_extension_move</span>(Cfg&amp; cfg) {
  <span class="pl-c">// Add user-defined implementation here ...</span>

  <span class="pl-c">// Invariant: If the previous invocation of extension_move() returned true, this</span>
  <span class="pl-c">// method must return cfg to its original state. </span>

  <span class="pl-k">return</span>;
}</pre></div>

<p>As above, both performing and undoing a transformation should leave a control flow graph in a valid state. In general, this can be performed by invoking the <code>Cfg::recompute()</code> method. However because these methods are on STOKE's critical path, the faster <code>Cfg::recompute_defs()</code> method should be used for transformations that do not modify control flow structure and only potentially invalidate data-flow values.</p>

<h2>
<a id="performance-term" class="anchor" href="#performance-term" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance Term</h2>

<p>Performance term types are defined in <code>src/cost/performance_term.h</code> along with an additional type for user-defined extensions.</p>

<div class="highlight highlight-c++"><pre><span class="pl-st">enum</span> <span class="pl-st">class</span> <span class="pl-en">PerformanceTerm</span> {
  NONE,
  SIZE,
  LATENCY,

  <span class="pl-c">// Add user-defined extensions here ...</span>
  EXTENSION
};</pre></div>

<p>Performance term type is specified using the <code>--perf</code> command line argument. This value controls the behavior of the <code>CostFunction::evaluate_performance() const</code> method, which dispatches to the family of <code>CostFunction::xxxxx_performance() const</code> methods. User-defined extensions should be placed in the <code>CostFunction::extension_performance() const</code> method, which can be triggered by specifying <code>--perf extension</code>.</p>

<div class="highlight highlight-c++"><pre>Cost <span class="pl-en">CostFunction::extension_performance</span>(<span class="pl-s">const</span> Cfg&amp; cfg) <span class="pl-s">const</span> { 
  Cost res = <span class="pl-c1">0</span>;                                                  

  <span class="pl-c">// Add user-defined implementation here ... </span>

  <span class="pl-c">// Invariant: Return value should not exceed max_performance_cost </span>
  <span class="pl-s3">assert</span>(res &lt;= max_performance_cost); 

  <span class="pl-k">return</span> res;  
}</pre></div>

<h2>
<a id="correctness-term" class="anchor" href="#correctness-term" aria-hidden="true"><span class="octicon octicon-link"></span></a>Correctness Term</h2>

<p>Correctness term types are defined in <code>src/cost/reduction.h</code> along with an additional type for user-defined extensions.</p>

<div class="highlight highlight-c++"><pre><span class="pl-st">enum</span> <span class="pl-st">class</span> <span class="pl-en">Reduction</span> {
  SUM,
  MAX,

  <span class="pl-c">// Add user-defined extensions here ...</span>
  EXTENSION
};</pre></div>

<p>Correctness term type is specified using the <code>--reduction</code> command line argument. This value controls the behavior of the <code>CostFunction::evaluate_correctness()</code> method, which dispatches to the family of <code>CostFunction::xxxxx_correctness()</code> methods, each of which represent a  method for aggregating errors observed across testcases. User-defined extensions should be placed in the <code>CostFunction::extension_correctness()</code> method, which can be triggered by specifying <code>--reduction extension</code>.</p>

<div class="highlight highlight-c++"><pre>Cost <span class="pl-en">CostFunction::extension_correctness</span>(<span class="pl-s">const</span> Cfg&amp; cfg, Cost max) {                                             
  Cost res = <span class="pl-c1">0</span>;                                                                                                  

  <span class="pl-c">// Add user-defined implementation here ... </span>

  <span class="pl-c">// This method is not required to examine all testcases. Implementations                                       </span>
  <span class="pl-c">// that compute res iteratively may stop executing and return max once res                                     </span>
  <span class="pl-c">// equals or exceeds that value.                                                                               </span>

  <span class="pl-c">// Invariant 1: Return value should not exceed max_correctness_cost                                            </span>
  <span class="pl-s3">assert</span>(res &lt;= max_correctness_cost);                                                                           

  <span class="pl-k">return</span> res;                                                                                                    
}</pre></div>

<h2>
<a id="live-out-error" class="anchor" href="#live-out-error" aria-hidden="true"><span class="octicon octicon-link"></span></a>Live-out Error</h2>

<p>Live-out error measurement types are defined in <code>src/cost/distance.h</code> along with an additional type for user-defined extensions.</p>

<div class="highlight highlight-c++"><pre><span class="pl-st">enum</span> <span class="pl-st">class</span> <span class="pl-en">Distance</span> {
  HAMMING,
  ULP,

  <span class="pl-c">// Add user-defined extensions here ...</span>
  EXTENSION
};</pre></div>

<p>Measurement type is specified using the <code>--distance</code> command line argument. This value controls the behavior of the <code>CostFunction::evaluate_distance() const</code> method, which dispatches to the family of <code>CostFunction::xxxxx_distance() const</code> methods, each of which represent a method computing the distance between 64-bit values. User-defined extensions should be placed in the <code>CostFunction::extension_distance() const</code> method, which can be triggered by specifying <code>--distance extension</code>.</p>

<div class="highlight highlight-c++"><pre>Cost <span class="pl-en">CostFunction::extension_distance</span>(<span class="pl-s3">uint64_t</span> x, <span class="pl-s3">uint64_t</span> y) <span class="pl-s">const</span> {                                            
  Cost res = <span class="pl-c1">0</span>;

  <span class="pl-c">// Add user-defined implementation here ...                                                                    </span>

  <span class="pl-c">// Invariant 1: Return value should not exceed max_error_cost                                                  </span>

  <span class="pl-k">return</span> res;                                                                                                    
}</pre></div>

<h2>
<a id="verification-strategy" class="anchor" href="#verification-strategy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Verification Strategy</h2>

<p>Verification strategy types are defined in <code>src/verifier/strategy.h</code> along with an additional type for user-defined extensions.</p>

<div class="highlight highlight-c++"><pre><span class="pl-st">enum</span> <span class="pl-st">class</span> <span class="pl-en">Strategy</span> {
  NONE,
  HOLD_OUT,

  <span class="pl-c">// Add user-defined extensions here ...</span>
  EXTENSION
};</pre></div>

<p>Strategy type is specified using the <code>--strategy</code> command line argument. This value controls the behavior of the <code>Verifier::verify()</code> method, which dispatches to the family of <code>Verifier::xxxxx_verify() const</code> methods, each of which represent a method for verifying correctness. User-defined extensions should be placed in the <code>Verifier::extension_verify()</code> method, which can be triggered by specifying <code>--strategy extension</code>.</p>

<div class="highlight highlight-c++"><pre><span class="pl-st">bool</span> <span class="pl-en">Verifier::extension_verify</span>(<span class="pl-s">const</span> Cfg&amp; target, <span class="pl-s">const</span> Cfg&amp; rewrite) {                                         
    <span class="pl-c">// Add user-defined implementation here ...</span>

    <span class="pl-c">// Invariant 1. If this method returns false and is able to produce a </span>
    <span class="pl-c">// counter example explaining why, counter_example_available_ should be</span>
    <span class="pl-c">// set to true.</span>

    <span class="pl-c">// Invariant 2. If this method returns false, and it is able (see above), </span>
    <span class="pl-c">// counter_example_ should be set to a CpuState that will cause target and </span>
    <span class="pl-c">// rewrite to produce different values.</span>

    <span class="pl-c">// Invariant 3. If this method produces a counter example, it should be</span>
    <span class="pl-c">// unique relative to all previously produced counter examples.</span>

  <span class="pl-k">return</span> <span class="pl-c1">true</span>;
} </pre></div>

<h2>
<a id="command-line-args" class="anchor" href="#command-line-args" aria-hidden="true"><span class="octicon octicon-link"></span></a>Command Line Args</h2>

<p>Command line arguments can be added to any of the STOKE subcommands using the following syntax. Argument separators which are printed as part of help messages are specified by defining a heading variable:</p>

<div class="highlight highlight-c++"><pre><span class="pl-st">auto</span>&amp; heading = Heading::create(<span class="pl-s1"><span class="pl-pds">"</span>Heading Description:<span class="pl-pds">"</span></span>);</pre></div>

<p>Command line flags are specified by declaring a <code>FlagArg</code>.</p>

<pre lang="c+++"><code>auto&amp; flag = FlagArg::create("flag_name")
  .alternate("alternate_flag_name")
  .description("What this flag does");
</code></pre>

<p>Any of the built-in c++ primitve types are specified by declaring a <code>ValueArg</code>.</p>

<div class="highlight highlight-c++"><pre><span class="pl-st">auto</span>&amp; val = ValueArg&lt;<span class="pl-st">int</span>&gt;::create(<span class="pl-s1"><span class="pl-pds">"</span>value_name<span class="pl-pds">"</span></span>)
  .alternate(<span class="pl-s1"><span class="pl-pds">"</span>alternate_value_name<span class="pl-pds">"</span></span>)
  .usage(<span class="pl-s1"><span class="pl-pds">"</span>&lt;int&gt;<span class="pl-pds">"</span></span>)
  .description(<span class="pl-s1"><span class="pl-pds">"</span>What this value represents<span class="pl-pds">"</span></span>)
  .default_val(<span class="pl-c1">0</span>);</pre></div>

<p>User-defined types are specified by additionally providing function objects that define I/O methods.</p>

<div class="highlight highlight-c++"><pre><span class="pl-st">struct</span> <span class="pl-en">T</span> {
  <span class="pl-st">int</span> x, y, z;
};

<span class="pl-st">struct</span> <span class="pl-en">Reader</span> {
  <span class="pl-st">void</span> <span class="pl-en">operator</span>()(istream&amp; is, T&amp; t) <span class="pl-s">const</span> {
    is &gt;&gt; t.<span class="pl-vo">x</span> &gt;&gt; t.<span class="pl-vo">y</span> &gt;&gt; t.<span class="pl-vo">z</span>;
  }
};

<span class="pl-st">struct</span> <span class="pl-en">Writer</span> {
  <span class="pl-st">void</span> <span class="pl-en">operator</span>()(ostream&amp; os, <span class="pl-s">const</span> T&amp; t) <span class="pl-s">const</span> {
    os &lt;&lt; t.<span class="pl-vo">x</span> &lt;&lt; <span class="pl-s1"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; t.<span class="pl-vo">y</span> &lt;&lt; <span class="pl-s1"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; t.<span class="pl-vo">z</span>;
  }
};

<span class="pl-st">auto</span>&amp; val = ValueArg&lt;T, Reader, Writer&gt;::create(<span class="pl-s1"><span class="pl-pds">"</span>value_name<span class="pl-pds">"</span></span>)
  .alternate(<span class="pl-s1"><span class="pl-pds">"</span>alternate_value_name<span class="pl-pds">"</span></span>)
  .usage(<span class="pl-s1"><span class="pl-pds">"</span>&lt;int&gt; &lt;int&gt; &lt;int&gt;<span class="pl-pds">"</span></span>)
  .description(<span class="pl-s1"><span class="pl-pds">"</span>What this value represents<span class="pl-pds">"</span></span>)
  .default_val({<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>});</pre></div>

<p>For complex values that are better suited to being read from files, a <code>FileArg</code> may be more appopriate than a <code>ValueArg</code>. The syntax is identical.</p>

<div class="highlight highlight-c++"><pre><span class="pl-st">auto</span>&amp; val = FileArg&lt;Complex, ComplexReader, ComplexWriter&gt;::create(<span class="pl-s1"><span class="pl-pds">"</span>value_name<span class="pl-pds">"</span></span>)
  .alternate(<span class="pl-s1"><span class="pl-pds">"</span>alternate_value_name<span class="pl-pds">"</span></span>)
  .usage(<span class="pl-s1"><span class="pl-pds">"</span>&lt;complex representation&gt;<span class="pl-pds">"</span></span>)
  .description(<span class="pl-s1"><span class="pl-pds">"</span>What this value represents<span class="pl-pds">"</span></span>)
  .default_val(Complex());</pre></div>

<h1>
<a id="frequently-asked-questions" class="anchor" href="#frequently-asked-questions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Frequently Asked Questions</h1>

<p>To appear.</p>

<h1>
<a id="feedback" class="anchor" href="#feedback" aria-hidden="true"><span class="octicon octicon-link"></span></a>Feedback</h1>

<p>Questions and comments are encouraged. The best way to contact the developers is with the built-in github issue tracker.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">STOKE maintained by <a href="https://github.com/eschkufz">eschkufz</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
